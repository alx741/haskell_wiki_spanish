== Introducción ==

Haskell es un lenguaje funcional (donde todo se hace con llamadas a funciones),
estático, implícitamente tipado (los [[type|tipo]]s los revisa el compilador, pero no
hace falta declararlos), perezoso (nada se hace hasta que es completamente
necesario). Los lenguajes populares más parecidos son la familia ML (que no son,
sin embargo, lenguajes perezosos).

El compilador de Haskell más común es [[GHC]]. Puede descargarlo de
http://www.haskell.org/ghc/download . Los ejecutables de GHC están disponibles
para [[GNU/Linux]], [[BSD | FreeBSD]], [[Mac OS x|MacOS]], [[Windows]], y
[[Solaris]].  Una vez instalado [[GHC]], se tienen dos programas que son de
interés ahora: <tt>ghc</tt>, y <tt>[[GHC/GHCi | ghci]]</tt>.  El primero compila
librerías y aplicaciones escritas en Haskell a código binario.  El segundo es un
interprete que permite escribir código Haskell y obtener un resultado inmediato.


== Expresiones simples ==

Es posible escribir varias expresiones matemáticas directamente en <tt>ghci</tt>
y obtener un resultado.  <tt>Prelude</tt> es el prompt por defecto de GHCi.

  Prelude> 3 * 5
  15
  Prelude> 4 ^ 2 - 1
  15
  Prelude> (1 - 5)^(3 * 2 - 4)
  16

Las cadenas van entre "comillas dobles."  Puede concatenarlas con
<hask>++</hask>.

  Prelude> "Hello"
  "Hello"
  Prelude> "Hello" ++ ", Haskell"
  "Hello, Haskell"

Las [[function|funciones]] se llaman colocando los argumentos directamente
después del nombre de la función.  No hay paréntesis en la llamada a la función:

  Prelude> succ 5
  6
  Prelude> truncate 6.59
  6
  Prelude> round 6.59
  7
  Prelude> sqrt 2
  1.4142135623730951
  Prelude> not (5 < 3)
  True
  Prelude> gcd 21 14
  7

== La consola ==

Las [[Introduction to IO|Acciones I/O]] se pueden usar para leer y escribir en
la consola.  Algunas son:

  Prelude> putStrLn "Hello, Haskell"
  Hello, Haskell
  Prelude> putStr "No newline"
  No newline
  Prelude> print (5 + 4)
  9
  Prelude> print (1 < 2)
  True

Las funciones <hask>putStr</hask> y <hask>putStrLn</hask> imprimen cadenas en la
terminal.  La función <hask>print</hask> imprime cualquier tipo de valor.  (Si
se hace <hask>print</hask> de una cadena, tendrá comillas).

Si necesita múltiples acciones I/O en una expresión, puede usar un bloque
<hask>do</hask>.  Las acciones se separan con punto y coma.

  Prelude> do { putStr "2 + 2 = " ; print (2 + 2) }
  2 + 2 = 4
  Prelude> do { putStrLn "ABCDE" ; putStrLn "12345" }
  ABCDE
  12345

La lectura se puede hacer con <haske>getLine</hask> (que retorna una cadena
<hask>String</hask>) o <hask>readLn</hask> (que retorna un valor de cualquier
tipo que se desee).  El símbolo <hask> <- </hask> se usa para asignar un nombre
al resultado de la acción I/O.

  Prelude> do { n <- readLn ; print (n^2) }
  4
  16

(El 4 fue la etrada.  El 16 la salida)

Existe otra forma de escribir los bloques <hask>do</hask>.  Si se suprimen las
llaves y los punto y coma, la indentación se vuelve importante.  Esto no
funciona muy bien en <tt>ghci</tt>, pero intente poniéndolo en un fichero (por
ejemplo, <tt>Test.hs</tt>) y compilelo.

<haskell>
main = do putStrLn "What is 2 + 2?"
          x <- readLn
          if x == 4
              then putStrLn "You're right!"
              else putStrLn "You're wrong!"
</haskell>

Puede compilar con <tt>ghc --make Test.hs</tt>, y el resultado se llamará
<tt>Test</tt>.  (en [[Windows]], <tt>Test.exe</tt>) Se tiene una expresión
<hask>if</hask> como un extra.

El primer carácter no blanco luego de <hask>do</hask> es especial.  En este
caso, es la <tt>p</tt> en <hask>putStrLn</hask>.  Cada linea que empieza en la
misma columna que la <hask>p</hask> es otra instrucción en el bloque
<hask>do</hask>.  Si se indenta más, se vuelve parte de la instrucción anterior.
Si se indenta menos, se termina el bloque <hask>do</hask>.  Esto se llama
"layout", y Haskell lo usa para evitar el uso de puntos y coma y llaves todo el
tiempo. (Las frases <hask>then</hask> y <hask>else</hask> deben estar indentadas
por esta razón. Si empiezan en la misma columna, serán instrucciones separadas,
lo que sería incorrecto).

(Nota: '''No''' indente con tabulaciones si está usando "layout". Técnicamente
funcionará si usa tabulaciones de 8 espacios, pero no es una buena idea.
Tampoco use fuentes proporcionales que, aparentemente algunas personas usan,
incluso para programar!).


== Tipos Simples ==

Hasta ahora no se a mencionado ni un solo [[type|tipo]].  Esto es por que
Haskell hace inferencia de tipos.  Generalmente no es necesario declararlos a
menos que se así se quiera.  Si desea declarar tipos, se puede usar
<hask>::</hask> para hacerlo.

  Prelude> 5 :: Int
  5
  Prelude> 5 :: Double
  5.0

[[type|Tipos]] (y las [[class|clases]] de tipos, de las cuales se hablará luego)
siempre empiezan con una letra mayúscula.  Las variables siempre empiezan con
una letra minúscula.  Esta es una regla del lenguaje, no una [[Studly capitals||convención]].

Se puede preguntar a <tt>ghci</tt> que tipo se ha elegido para algo.  Esto es
útil por que generalmente no hay necesidad de declarar los tipos.

  Prelude> :t True
  True :: Bool
  Prelude> :t 'X'
  'X' :: Char
  Prelude> :t "Hello, Haskell"
  "Hello, Haskell" :: [Char]

(En caso de que lo haya notado, <hask>[Char]</hask> es otra forma de decir
<hask>String</hask>.  Vea la [[#Structured data|sección sobre listas]] luego.)

Algunas cosas se tornan más interesantes con los números.

  Prelude> :t 42
  42 :: (Num t) => t
  Prelude> :t 42.0
  42.0 :: (Fractional t) => t
  Prelude> :t gcd 15 20
  gcd 15 20 :: (Integral t) => t

Estos tipos usan "Clases de tipo". Significan:

* <hask>42</hask> se puede usar como cualquier tipo numérico.  (Esta es la razón por la que podemos declarar <hask>5</hask> como <hask>Int</hask> o como <hask>Double</hask>).
* <hask>42.0</hask> puede ser cualquier tipo fraccionario, pero no un tipo integral.
* <hask>gcd 15 20</hask> (que es una llamada de función) puede ser cualquier tipo integral, pero no un tipo fraccionario.

Existen 5 tipos numéricos en el "preludio" de Haskell (la parte de la librería que se obtiene sin tener que importar nada):

* <hask>Int</hask> es un entero con al menos 30 bits de precisión.
* <hask>Integer</hask> es un entero con precisión ilimitada.
* <hask>Float</hask> es un numero de punto flotante con precisión simple.
* <hask>Double</hask> es un numero de punto flotante con precisión doble.
* <hask>Rational</hask> es un tipo fraccionario, sin error de redondeo.

Los cinco son '''instancias''' de la clase de tipo <hask>Num</hask>.  Los
primeros dos son '''instancias''' de <hask>Integral</hask>, y los últimos tres
son '''instancias''' de <hask>Fractional</hask>.

Poniéndolo todo junto:

  Prelude> gcd 42 35 :: Int
  7
  Prelude> gcd 42 35 :: Double

  <interactive>:1:0:
      No instance for (Integral Double)

El tipo final es un <hask>()</hask>, que se pronuncia "unidad".  Solo tiene un
valor, que se escribe también como <hask>()</hask> y se pronuncia "unidad" de
igual manera.

  Prelude> ()
  ()
  Prelude> :t ()
  () :: ()

Se puede pensar en este tipo como en <tt>void</tt> de la familia de lenguajes de
C.  Se puede retornar <hask>()</hask> desde una acción de I/O cuando no se
quiere retornar nada en particular.
